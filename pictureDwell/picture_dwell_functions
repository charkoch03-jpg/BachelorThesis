"""
Reusable functions to detect FIRST and LAST picture dwells.

"""

from __future__ import annotations
from typing import Optional, Tuple
import numpy as np

# ---------- small helpers ----------

def as_1d(a: np.ndarray) -> np.ndarray:
    return np.asarray(a, dtype=float).ravel()

def is_stable(window: np.ndarray, stability_threshold: float) -> bool:
    if window.size == 0:
        return False
    wmax = np.nanmax(window); wmin = np.nanmin(window)
    if np.isnan(wmax) or np.isnan(wmin):
        return False
    return (wmax - wmin) <= stability_threshold

def indices_to_times(
    t: np.ndarray,
    start_idx: Optional[int],
    end_idx_inclusive: Optional[int],
    *,
    relative_to_zero: bool = False,
) -> Tuple[float, float]:
    """
    Convert indices to ms. If relative_to_zero=True, subtract t[0].
    Returns (start_ms, end_ms) or (nan, nan) if invalid.
    """
    t = as_1d(t)
    n = t.size
    if (
        start_idx is None or end_idx_inclusive is None
        or start_idx < 0 or end_idx_inclusive < 0
        or start_idx >= n or end_idx_inclusive >= n
        or end_idx_inclusive < start_idx
    ):
        return np.nan, np.nan
    s = float(t[start_idx]); e = float(t[end_idx_inclusive])
    if relative_to_zero:
        z = float(t[0]); s -= z; e -= z
    return s, e

def side_from_x(x_val: float, center: float) -> int:
    """Return 0 for left, 1 for right."""
    return 0 if x_val < center else 1

# ---------- picture dwell detection ----------

def find_first_picture_dwell(
    x: np.ndarray,
    t: np.ndarray,
    *,
    picture_onset_idx: int,
    center: float,
    band: float,
    window_size: int,
    stability_threshold: float,
    end_idx_exclusive: Optional[int] = None,
) -> Tuple[Optional[int], Optional[int], Optional[int]]:
    """
    FIRST dwell: the first stable excursion outside center band after picture onset.
    Start = first stable window outside [center-band, center+band].
    End   = start of return to the center band (or end_idx_exclusive-1 if no return before end of trial).
    Returns (start_idx, end_idx_inclusive, side) or (None, None, None).
    """
    x = as_1d(x); t = as_1d(t)
    n = x.size
    if n == 0 or t.size != n or picture_onset_idx >= n:
        return None, None, None

    stop = n if end_idx_exclusive is None else int(min(max(0, end_idx_exclusive), n))
    if stop - picture_onset_idx < window_size:
        return None, None, None

    lower = center - band
    upper = center + band

    i = picture_onset_idx
    while i <= stop - window_size:
        xi = x[i]
        # find out if it left center band 
        if not (lower <= xi <= upper):
            win = x[i:i + window_size]
            if is_stable(win, stability_threshold):
                start_idx = i  # mark the start at the first stable point outside band
                # find end: first time back in band
                j = i + window_size
                end_idx = None
                while j < stop:
                    if lower <= x[j] <= upper:
                        end_idx = j
                        break
                    j += 1
                if end_idx is None:
                    end_idx = stop - 1
                return start_idx, end_idx, side_from_x(x[start_idx], center)
        i += 1

    return None, None, None

def find_last_picture_dwell_after(
    x: np.ndarray,
    t: np.ndarray,
    *,
    search_from_idx: int,
    center: float,
    band: float,
    window_size: int,
    stability_threshold: float,
    end_idx_exclusive: Optional[int] = None,
) -> Tuple[Optional[int], Optional[int], Optional[int]]:
    """
    LAST dwell: scan after `search_from_idx` for subsequent stable excursions,
    keep updating until the last one (before end_idx_exclusive).
    Returns (start_idx, end_idx_inclusive, side) or (None, None, None).
    """
    x = as_1d(x); t = as_1d(t)
    n = x.size
    if n == 0 or t.size != n:
        return None, None, None

    stop = n if end_idx_exclusive is None else int(min(max(0, end_idx_exclusive), n))
    if stop - search_from_idx < window_size:
        return None, None, None

    lower = center - band
    upper = center + band

    last_s = None; last_e = None; last_side = None
    i = max(search_from_idx, 0)

    while i <= stop - window_size:
        xi = x[i]
        if not (lower <= xi <= upper):
            win = x[i:i + window_size]
            if is_stable(win, stability_threshold):
                s_idx = i
                j = i + window_size
                e_idx = None
                while j < stop:
                    if lower <= x[j] <= upper:
                        e_idx = j
                        break
                    j += 1
                if e_idx is None:
                    e_idx = stop - 1
                last_s = s_idx
                last_e = e_idx
                last_side = side_from_x(x[s_idx], center)
                i = e_idx + 1
                continue
        i += 1

    return last_s, last_e, last_side
